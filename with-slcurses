#!/bin/sh
# $Id: with-slcurses,v 1.47 2017/09/13 23:15:04 tom Exp $
# -----------------------------------------------------------------------------
# Copyright 2017 by Thomas E. Dickey
#
#                         All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the
# sale, use or other dealings in this Software without prior written
# authorization.
# -----------------------------------------------------------------------------
# Pretend that "slcurses" is a variant of 4.3BSD curses, with a few features
# added and removed.

failed() {
	echo "? $*" >&2
	exit 1
}

tell() {
	[ -n "$OPT_V" ] && echo "$*"
}

verbose() {
	if [ -t 1 ]
	then
		"$@"
	else
		"$@" 2>&1|sed -e "s,$MYTEMP,\${MYTEMP},"
	fi
}

do_links() {
	verbose ln $OPT_V -sf $1 $MYTEMP/$2
}

MYTEMP=$(mktemp -d)
[ -z "$MYTEMP" ] && failed "mktemp"
[ -d "$MYTEMP" ] || failed "mktemp"
trap "cd; rm -rf $MYTEMP" 0 1 2 3 15

# use the verbose option for debugging the script
OPT_V=
[ -t 1 ] || OPT_V="-v"

PKGTOOL=pkg-config
unset CPPFLAGS
unset LIBS
found=no
for NAME in slang2 slang
do
	$PKGTOOL --exists $NAME 2>/dev/null || continue
	CPPFLAGS="$($PKGTOOL --cflags $NAME 2>/dev/null )"
	LIBS="$($PKGTOOL --libs $NAME 2>/dev/null )"
	found=yes
	break
done
[ $found = no ] && failed "could not find slang-package"

case "x$LIBS" in
x*-L*)
	tell "found libdir"
	libfile=
	libroot="libslang${LIBS##*-lslang}"
	libroot=${libroot%% *}
	libdir="${LIBS##*-L}"
	libdir=${libdir%% *}
	for tail in $libdir/$libroot.*
	do
		if [ -f "$tail" ]
		then
			libfile="$tail"
			break
		fi
	done
	[ -n "$libfile" ] || failed "could not find library file in $LIBS"
	;;
*)
	tell "find libdir..."
	libdir=
	for head in /usr/lib /usr/lib/* /usr/lib/*$(arch)*
	do
		[ -d "$head" ] || continue
		for tail in $head/libslang*
		do
			if [ -f "$tail" ]
			then
				libdir="$head"
				libfile="$tail"
				break
			fi
		done
		[ -n "$libdir" ] && break
	done
	[ -n "$libdir" ] || failed "cannot find library directory"
	LIBS="-L$MYTEMP $LIBS"
	;;
esac

for fake in curses ncurses ncursesw tinfo tinfow termcap
do
	do_links $libfile lib$fake.a
done

cat >$MYTEMP/curses.h <<'EOF'
/*
 * Copyright 2017, Thomas E. Dickey
 *
 * This file is generated by "with-slcurses", and is subject to the same
 * licensing guidelines as that script.
 */
#ifndef FAKE_CURSES_H
#define FAKE_CURSES_H 1

#include <stdlib.h>
#include <stdarg.h>

#include <slcurses.h>

/*
 * Define INLINE to static or extern, depending on whether you want to see
 * symbols for each inline'd function.
 */
#undef INLINE
#define INLINE static

#if 0
static void _dprintf(const char *fmt, ...) SLATTRIBUTE_((format(printf,1,2)));
static void _dprintf(const char *fmt, ...)
{
	FILE *fp = fopen("trace.log", "a");
	if (fp != 0) {
		va_list ap;
		va_start(ap,fmt);
		vfprintf(fp, fmt, ap);
		va_end(ap);
		fclose(fp);
	}
}
#define DPRINTF(p) _dprintf p
#else
#define DPRINTF(p) /* nothing */
#endif

/*
 * Cancel a few things where slang's header files confuse configure scripts.
 */
/* slang library does not support overlapping windows */
#undef copywin
#undef overlay
#undef overwrite

/* nor does it have a terminfo interface (only termcap) */
#undef tigetstr

#undef HAVE_LIBFORM
#undef HAVE_LIBMENU
#undef HAVE_LIBPANEL

#undef HAVE_LIBFORMW
#undef HAVE_LIBMENUW
#undef HAVE_LIBPANELW

/*
 * All versions of curses define OK/ERR.  SLcurses only got this halfway.
 */
#ifndef OK
#define OK (0)
#endif

#ifndef ERR
#define ERR (-1)
#endif

/*
 * Rename the inline functions to make it easier to see where they came from.
 */
#undef _vawscanw
#undef copywin
#undef curs_set
#undef getbkgd
#undef has_ic
#undef has_il
#undef idlok
#undef keyname
#undef meta
#undef mvwscanw
#undef newterm
#undef overlay
#undef overwrite
#undef pair_content
#undef scanw
#undef tgetent
#undef tgetstr
#undef unctrl
#undef waddchnstr
#undef wbkgd
#undef wbkgdset
#undef wechochar
#undef wgetnstr
#undef winchnstr
#undef winnstr
#undef wredrawln
#undef wscanw

#ifdef MODULE_NAME
#define CONCAT2(a,b,c) a ## b ## c
#define CONCAT(a,b) CONCAT2(_,a,b)
#define _vawscanw   CONCAT(MODULE_NAME,__vawscanw)
#define copywin     CONCAT(MODULE_NAME,_copywin)
#define curs_set    CONCAT(MODULE_NAME,_curs_set)
#define getbkgd     CONCAT(MODULE_NAME,_getbkgd)
#define has_ic      CONCAT(MODULE_NAME,_has_ic)
#define has_il      CONCAT(MODULE_NAME,_has_il)
#define idlok       CONCAT(MODULE_NAME,_idlok)
#define keyname     CONCAT(MODULE_NAME,_keyname)
#define meta        CONCAT(MODULE_NAME,_meta)
#define mvwscanw    CONCAT(MODULE_NAME,_mvwscanw)
#define newterm     CONCAT(MODULE_NAME,_newterm)
#define overlay     CONCAT(MODULE_NAME,_overlay)
#define overwrite   CONCAT(MODULE_NAME,_overwrite)
#define pair_content CONCAT(MODULE_NAME,_pair_content)
#define scanw       CONCAT(MODULE_NAME,_scanw)
#define tgetent     CONCAT(MODULE_NAME,_tgetent)
#define tgetstr     CONCAT(MODULE_NAME,_tgetstr)
#define unctrl      CONCAT(MODULE_NAME,_unctrl)
#define waddchnstr  CONCAT(MODULE_NAME,_waddchnstr)
#define wbkgd       CONCAT(MODULE_NAME,_wbkgd)
#define wbkgdset    CONCAT(MODULE_NAME,_wbkgdset)
#define wechochar   CONCAT(MODULE_NAME,_wechochar)
#define wgetnstr    CONCAT(MODULE_NAME,_wgetnstr)
#define winchnstr   CONCAT(MODULE_NAME,_winchnstr)
#define winnstr     CONCAT(MODULE_NAME,_winnstr)
#define wredrawln   CONCAT(MODULE_NAME,_wredrawln)
#define wscanw      CONCAT(MODULE_NAME,_wscanw)
#endif

/*
 * Simulate termcap-interface with slang.  It has no comparable interface for
 * terminfo, since it uses only termcap names.
 *
 * The cast in tgetent() will get a compiler warning.  There are several
 * functions in SLcurses which are missing a SLFUTURE_CONST, including
 * SLcurses_waddnstr().
 */
#define tgoto(cap, col, row) SLtt_tgoto(cap, col, row)
#define tgetflag(name)       SLtt_tgetflag(name)
#define tgetnum(name)        SLtt_tgetnum(name)
#define tputs(s, c, f)       SLtt_tputs(s, c, f)

INLINE int tgetent(char *, SLFUTURE_CONST char *);
inline int tgetent(char *bp, SLFUTURE_CONST char *name)
{
	(void) bp;
	return SLtt_tgetent((char *) name);
}

INLINE char * tgetstr(SLFUTURE_CONST char *, char **);
inline char * tgetstr(SLFUTURE_CONST char *name, char **ap)
{
	(void) ap;
	return SLtt_tgetstr(name);
}

/*
 * These were overlooked in slcurses.h
 */
#define KEY_IC	SL_KEY_IC
#define KEY_DC	SL_KEY_DELETE

#define PAIR_NUMBER(a)	 ((a)>>24)

#define getbegyx(w,y,x)  (y=(w)->_begy, x=(w)->_begx)
#define setscrreg(a,b)   wsetscrreg(stdscr,a,b)
#define insertln()       winsertln(stdscr)
#define deleteln()       SLtt_delete_nlines(1)

#define derwin(orig, nlines, ncols, begin_y, begin_x) \
	((orig) \
	 ? subwin(orig, nlines, ncols, \
		  (orig)->_begy + begin_y, \
		  (orig)->_begx + begin_x) \
	 : 0)

#define notimeout(w,b)   do { ESCDELAY = (b) ? 100 : 0; } while (0)
#define halfdelay(n)     timeout((n) * 100)

#define erasechar()      KEY_BACKSPACE
#define killchar()       SLang_Abort_Char

#define baudrate()       SLang_TT_Baud_Rate
#define delay_output(ms) napms(ms)
#define intrflush(w,n)   SLcurses_nil

#define def_prog_mode SLcurses_nil
#define def_shell_mode SLcurses_nil
#define reset_prog_mode() SLang_init_tty(-1, 1, 0)
#define reset_shell_mode SLang_reset_tty

#define termname()	getenv("TERM")
#define longname()	"SLcurses does not provide long name"

#define A_ATTRIBUTES	(\
	A_NORMAL	|\
	A_BOLD		|\
	A_REVERSE	|\
	A_UNDERLINE	|\
	A_ALTCHARSET	|\
	A_BLINK		|\
	A_DIM		|\
	A_PROTECT	|\
	A_INVIS		)

/*
 * These could be supplied by the slang library, but are here just for the
 * ncurses-examples which use these symbols.
 */
#define KEY_BTAB	0x114
#define KEY_PREVIOUS	0x115
#define KEY_NEXT	0x116

/*
 * The slang library does not have a 7-bit mode.
 */
INLINE int meta(WINDOW *w, bool bf);
inline int meta(WINDOW *w, bool bf)
{
	(void) w;
	return (bf ? OK : ERR);
}

/*
 * This might be done more efficiently if SLcurses_placechar() were exported.
 */
#define echochar(c) wechochar(stdscr, c)
INLINE int wechochar(WINDOW *w, int c);
inline int wechochar(WINDOW *w, int c)
{
	int rc = waddch(w, c);
	wrefresh(w);
	return rc;
}

/*
 * The slang library has no way to provide a comparable function to newterm,
 * because it has no interface by which the input/output streams can be given.
 */
typedef struct _SCREEN SCREEN;
INLINE SCREEN *newterm(char *type, FILE *outfd, FILE *infd);
inline SCREEN *newterm(char *type, FILE *outfd, FILE *infd)
{
	if (infd != stdin
	 || outfd != stdout
	 || SLtt_initialize (type) != 0) {
		fprintf(stderr, "This library cannot simulate \"newterm\"\n");
		exit(EXIT_FAILURE);
	}
	initscr();
	return (SCREEN *)malloc(1);
}

/*
 * Work around a bug in SLcurses: curs_set should not require a refresh...
 */
INLINE int curs_set(int mode);
inline int curs_set(int mode)
{
	SLtt_set_cursor_visibility(mode);
	SLtt_flush_output();
	return 1;
}

/*
 * These are errors in slang headers.
 */
#undef touchline
#define touchline(w,s,c) SLsmg_touch_lines(s,c)

#undef hline
#define hline(c,n) SLsmg_draw_hline(n)

#undef vline
#define vline(c,n) SLsmg_draw_vline(n)

#undef whline
#define whline(w,c,n) SLsmg_draw_hline(n)

#undef wvline
#define wvline(w,c,n) SLsmg_draw_vline(n)

#define border(ls, rs, ts, bs, tl, tr, bl, br) box(stdscr, ls, ts)
#define wborder(win, ls, rs, ts, bs, tl, tr, bl, br) box(win, ls, ts)

#undef mvwinch
#define mvwinch(w,x,y) \
    ((-1 != wmove((w),(x),(y))) ? winch(w) : (chtype)(-1))

/*
 * Missing functions, added for ncurses-examples
 */
INLINE const char *unctrl(int c);
inline const char *unctrl(int c)
{
	static char table[256][6];
	char *result = 0;
	if (c >= 0 && c < 256) {
		result = &table[c][0];
		if (*result == 0) {
			char *s = result;
			if (c >= 128) {
				*s++ = 'M';
				*s++ = '-';
				c -= 128;
			}
			if (c < 32)
				sprintf(s, "^%c", c | '@');
			else if (c < 127)
				sprintf(s, "%c", c);
			else
				sprintf(s, "^?");
		}
	}
	return (const char *)result;
}

INLINE const char *keyname(int c);
inline const char *keyname(int c)
{
#define SL_KEYNAMES(name) { name, #name }
	static struct {
		int code;
		const char *name;
	} table[] = {
		SL_KEYNAMES(KEY_DOWN),
		SL_KEYNAMES(KEY_UP),
		SL_KEYNAMES(KEY_LEFT),
		SL_KEYNAMES(KEY_RIGHT),
		SL_KEYNAMES(KEY_A1),
		SL_KEYNAMES(KEY_C1),
		SL_KEYNAMES(KEY_B2),
		SL_KEYNAMES(KEY_A3),
		SL_KEYNAMES(KEY_C3),
		SL_KEYNAMES(KEY_REDO),
		SL_KEYNAMES(KEY_UNDO),
		SL_KEYNAMES(KEY_BACKSPACE),
		SL_KEYNAMES(KEY_PPAGE),
		SL_KEYNAMES(KEY_NPAGE),
		SL_KEYNAMES(KEY_HOME),
		SL_KEYNAMES(KEY_END),
		SL_KEYNAMES(KEY_ENTER),
		SL_KEYNAMES(KEY_IC),
		SL_KEYNAMES(KEY_DC),
		/* not in SLcurses */
		SL_KEYNAMES(KEY_BTAB),
		SL_KEYNAMES(KEY_PREVIOUS),
		SL_KEYNAMES(KEY_NEXT),
		{ 0, 0 }
	};
#undef SL_KEYNAMES
	const char *result = 0;
	if (c < 256) {
		result = unctrl(c);
	} else if (c < KEY_F0) {
		int n;
		for (n = 0; table[n].code; ++n) {
			if (table[n].code == c) {
				result = table[n].name;
				break;
			}
		}
	} else if (c < KEY_F0 + 60) {
		static char dummy[20];
		sprintf(dummy, "KEY_F%d", c - KEY_F0);
		result = dummy;
	}
	return result;
}

INLINE int wredrawln(WINDOW *w, int s, int c);
inline int wredrawln(WINDOW *w, int s, int c)
{
	(void) w;
	SLsmg_touch_lines(s,c);
	refresh();
	return OK;
}

/*
 * Reduce the number of missing functions for ncurses-examples
 */
#define mvaddchnstr(y,x,str,n)		mvwaddchnstr(stdscr,y,x,str,n)
#define mvaddchstr(y,x,str)		mvwaddchstr(stdscr,y,x,str)
#define mvinch(y,x)			mvwinch(stdscr,y,x)
#define mvinchnstr(y,x,s,n)		mvwinchnstr(stdscr,y,x,s,n)
#define mvinchstr(y,x,s)		mvwinchstr(stdscr,y,x,s)
#define mvinnstr(y,x,s,n)		mvwinnstr(stdscr,y,x,s,n)
#define mvinstr(y,x,s)			mvwinstr(stdscr,y,x,s)

#define mvwaddchnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))
#define mvwaddchstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))
#define mvwdelch(win,y,x)		(wmove(win,y,x) == ERR ? ERR : wdelch(win))
#define mvwgetch(win,y,x)		(wmove(win,y,x) == ERR ? ERR : wgetch(win))
#define mvwinchnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))
#define mvwinchstr(win,y,x,s)		(wmove(win,y,x) == ERR ? ERR : winchstr(win,s))
#define mvwinnstr(win,y,x,s,n)		(wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))
#define mvwinstr(win,y,x,s)		(wmove(win,y,x) == ERR ? ERR : winstr(win,s))

#define addchnstr(str,n)		waddchnstr(stdscr,str,n)
#define addchstr(str)			waddchstr(stdscr,str)
#define getstr(str)			wgetstr(stdscr,str)
#define inchnstr(s,n)			winchnstr(stdscr,s,n)
#define inchstr(s)			winchstr(stdscr,s)
#define innstr(s,n)			winnstr(stdscr,s,n)
#define insdelln(n)			winsdelln(stdscr,n)
#define instr(s)			winstr(stdscr,s)
#define redrawwin(win)			wredrawln(win, 0, (win)->_maxy+1)
#define waddchstr(win,str)		waddchnstr(win,str,-1)
#define wgetstr(w, s)			wgetnstr(w, s, -1)
#define winchstr(win, s)		winchnstr(win, s, -1)
#define winstr(win, s)			winnstr(win, s, -1)

/*
 * Some of these are stubs that might be converted to slang-calls
 */
INLINE int wbkgd(WINDOW *win, chtype ch);
inline int wbkgd(WINDOW *win, chtype ch)
{
	(void) win;
	(void) ch;
	return OK;
}
#define bkgd(ch) wbkgd(stdscr, ch)

INLINE int wbkgdset(WINDOW *win, chtype ch);
inline int wbkgdset(WINDOW *win, chtype ch)
{
	/* not-implemented */
	(void) win;
	(void) ch;
	return OK;
}
#define bkgdset(ch) wbkgdset(stdscr, ch)

INLINE chtype getbkgd(WINDOW *win);
inline chtype getbkgd(WINDOW *win)
{
	/* not-implemented */
	(void) win;
	return (chtype) ' ';
}

INLINE int has_ic(void);
inline int has_ic(void)
{
	/* not-implemented */
	return TRUE;
}

INLINE int has_il(void);
inline int has_il(void)
{
	/* not-implemented */
	return TRUE;
}

INLINE int idlok(WINDOW *, bool);
inline int idlok(WINDOW *win, bool bf)
{
	/* not-implemented */
	(void) win;
	return bf ? OK : FALSE;
}

/* Adapt definitions from sldisplay.c which should have been published. */

#if defined(SLTT_HAS_FAKECOLOR_SUPPORT) && (SIZEOF_LONG == 8)
#  define FG_MASK_LOW           0x000000000000FF00ULL
#  define FG_MASK_HIGH          0x0000FFFF00000000ULL
#  define FG_FAKE_COLOR         0x0000000000000001ULL
#  define BG_MASK_LOW           0x0000000000FF0000ULL
#  define BG_MASK_HIGH          0xFFFF000000000000ULL
#  define BG_FAKE_COLOR         0x0000000000000002ULL
#  define INVALID_ATTR          0xFFFFFFFFFFFFFFFFULL
#  define GET_FG(fgbg) \
   ((((fgbg)&FG_FAKE_COLOR)<<24) | (((fgbg)&FG_MASK_HIGH)>>24) \
        | (((fgbg)&FG_MASK_LOW)>>8))
#  define GET_BG(fgbg) \
	   ((((fgbg)&BG_FAKE_COLOR)<<23) | (((fgbg)&BG_MASK_HIGH)>>40) \
	        | (((fgbg)&BG_MASK_LOW)>>16))
#else
# define FG_MASK_LOW            0x0000FF00UL
# define FG_MASK_HIGH           0x00000000UL
# define BG_MASK                0x00FF0000UL
# define INVALID_ATTR           0xFFFFFFFFUL
# define GET_FG(fgbg) (((fgbg) & FG_MASK_LOW)>>8)
# define GET_BG(fgbg) (((fgbg) & BG_MASK) >> 16)
#endif

INLINE int pair_content(short pair, short *f, short *b);
inline int pair_content(short pair, short *f, short *b)
{
	int rc = ERR;
	if (SLtt_Use_Ansi_Colors) {
		SLtt_Char_Type brush = SLtt_get_color_object (pair);
		if (brush != INVALID_ATTR) {
			rc = OK;
			*f = GET_FG(brush);
			*b = GET_BG(brush);
		}
	}
	return rc;
}

INLINE int waddchnstr(WINDOW *win, const chtype *chstr, int n);
inline int waddchnstr(WINDOW *win, const chtype *chstr, int n)
{
	chtype ch;
	int save_y, save_x;
	getyx(win, save_y, save_x);
	if (n < 0) {
		for (n = 0; chstr[n] != 0; ++n) {
			;
		}
	}
	while ((n-- > 0) && ((ch = *chstr++) != 0)) {
		int width = (SLwchar_isprint (ch)
			     ? (SLsmg_is_utf8_mode ()
				? SLwchar_wcwidth (ch)
				: 1)
			     : 0);
		if (win->_curx + width > win->ncols)
			break;
		if (addch(ch) != OK)
			return ERR;
	}
	wmove(win, save_y, save_x);
	return OK;
}

INLINE int winchnstr(WINDOW *win, chtype *chstr, int n);
inline int winchnstr(WINDOW *win, chtype *chstr, int n)
{
	int y = win->_cury;
	int x = win->_curx;
	while (n-- > 0) {
		if (x >= (int) win->ncols)
			break;
		*chstr++ = win->lines[y][x++].main;
	}
	*chstr = 0;
	return OK;
}

INLINE int winnstr(WINDOW *win, char *str, int n);
inline int winnstr(WINDOW *win, char *str, int n)
{
	int y = win->_cury;
	int x = win->_curx;
	while (n-- > 0) {
		if (x >= (int) win->ncols)
			break;
		/* FIXME - this does not account for UTF-8 */
		*str++ = (char) (win->lines[y][x++].main & A_CHARTEXT);
	}
	*str = 0;
	return OK;
}

/*
 * wscanw, etc., use wgetnstr(), which is absent from SLcurses.
 */
INLINE int wgetnstr(WINDOW *win, char *str, int n);
inline int wgetnstr(WINDOW *win, char *str, int n)
{
	int rc = OK;
	int ch;
	int oldy = win->_cury;
	int oldx = win->_curx;
	int newy = ((oldy >= (int) win->nrows) && win->scroll_ok) ? oldy - 1 : oldy;
	int newx;
	bool done = FALSE;

	if (n <= 0)
		n = ((int) win->ncols - win->_curx);
	while (!done) {
		ch = wgetch(win);
		if (ch <= 0)
			break;
		switch (ch) {
		case '\r':
		case '\n':
			done = TRUE;
			break;
		case '\b':
			if ((int) win->_curx > oldx) {
				waddch(win, '\b');
				waddch(win, ' ');
				waddch(win, '\b');
			} else {
				flash();
			}
			break;
		default:
			if ((int) win->_curx < (oldx + n)) {
				waddch(win, ch);
			} else {
				flash();
			}
			break;
		}
	}
	newx = win->_curx;
	wmove(win, oldy, oldx);
	rc = winnstr(win, str, 1 + (newx - oldx));
	waddch(win, '\n');
	wmove(win, newy, oldx);
	return rc;
}

/*
 * The vsscanf function was not generally available in 1996 (it was proposed
 * for standardization in 1997), and the developers of SLcurses had no idea
 * how to make their own, nor how it might be used in curses.
 */
INLINE int _vawscanw(WINDOW *win, const char *fmt, va_list ap);
inline int _vawscanw(WINDOW *win, const char *fmt, va_list ap)
{
	int rc = ERR;
	int need = 1 + (win->ncols - win->_curx);
	char *buffer = malloc(need + 1);
	if (buffer != 0) {
		if ((rc = wgetnstr(win, buffer, need)) == OK) {
			rc = vsscanf(buffer, fmt, ap);
		}
		free(buffer);
	}
	return rc;
}

INLINE int scanw(const char *fmt, ...) SLATTRIBUTE_((format(scanf,1,2)));
inline int scanw(const char *fmt, ...)
{
	int rc;
	va_list ap;
	va_start(ap, fmt);
	rc = _vawscanw(stdscr, fmt, ap);
	va_end(ap);
	return rc;
}

INLINE int wscanw(WINDOW *win, const char *fmt, ...) SLATTRIBUTE_((format(scanf,2,3)));
inline int wscanw(WINDOW *win, const char *fmt, ...)
{
	int rc;
	va_list ap;
	va_start(ap, fmt);
	rc = _vawscanw(win, fmt, ap);
	va_end(ap);
	return rc;
}

INLINE int mvwscanw(WINDOW *win, int y, int x, char *fmt, ...) SLATTRIBUTE_((format(scanf,4,5)));
inline int mvwscanw(WINDOW *win, int y, int x, char *fmt, ...)
{
	int rc = wmove(win, y, x);
	if (rc == OK) {
		va_list ap;
		va_start(ap, fmt);
		rc = _vawscanw(win, fmt, ap);
		va_end(ap);
	}
	return rc;
}

/*
 * The slang library does not handle overlapping windows.  But copying one
 * window to another, using the same size, is too useful to disregard.  Besides
 * that, testcurs and xmas from the original set of test-programs rely upon
 * this since their first use in ncurses in 1994.  SLcurses pretends they do
 * not exist, by (mis)defining the functions to nil.
 *
 * This implementation checks for overlapping windows, and will simply return
 * an error in that case.
 */
INLINE int copywin(const WINDOW *srcwin, WINDOW *dstwin, int sminrow, int smincol, int dminrow, int dmincol, int dmaxrow, int dmaxcol, int mode);
inline int copywin(const WINDOW *srcwin, WINDOW *dstwin, int sminrow, int smincol, int dminrow, int dmincol, int dmaxrow, int dmaxcol, int mode)
{
	int yd, xd;
	int ys, xs;
	int ch;
	DPRINTF(("copywin %d,%d -> %d,%d (%d/%d,%d/%d)\n",
		sminrow, smincol,
		dminrow, dmincol,
		dmaxrow, dstwin->nrows - 1,
		dmaxcol, dstwin->ncols - 1));
	if (srcwin == 0 || dstwin == 0)
		return ERR;
	/* FIXME - check for overlapping windows */
	DPRINTF(("OK:\n"));
	for (yd = dminrow; yd < dmaxrow; ++yd) {
		ys = sminrow + (yd - dminrow);
		if (ys < 0 || yd < 0)
			continue;
		if (ys >= (int) srcwin->nrows)
			break;
		if (yd >= (int) dstwin->nrows)
			break;
		DPRINTF(("row %3d:", yd));
		for (xd = dmincol; xd < dmaxcol; ++xd) {
			xs = smincol + (xd - dmincol);
			if (xs < 0 || xd < 0)
				continue;
			if (xs >= (int) srcwin->ncols)
				break;
			if (xd >= (int) dstwin->ncols)
				break;
			ch = (char) (srcwin->lines[yd][xd].main & A_CHARTEXT);
			if (ch != ' ' || !mode) {
				dstwin->lines[yd][xd] = srcwin->lines[ys][xs];
			}
			DPRINTF(("%c", (char)(dstwin->lines[yd][xd].main & A_CHARTEXT)));
		}
		DPRINTF(("\n"));
	}
	touchwin(dstwin);
	return OK;
}

INLINE int overlay(const WINDOW *srcwin, WINDOW *dstwin);
inline int overlay(const WINDOW *srcwin, WINDOW *dstwin)
{
	return copywin(srcwin, dstwin, 0,0, 0,0,
		       (int)(srcwin)->nrows - 1,
		       (int)(srcwin)->ncols - 1,
		       TRUE);
}


INLINE int overwrite(const WINDOW *srcwin, WINDOW *dstwin);
inline int overwrite(const WINDOW *srcwin, WINDOW *dstwin)
{
	return copywin(srcwin, dstwin, 0,0, 0,0,
		       (int)(srcwin)->nrows - 1,
		       (int)(srcwin)->ncols - 1,
		       FALSE);
}

#endif /* FAKE_CURSES_H */
EOF
do_links $MYTEMP/curses.h ncurses.h 2>&1|sed -e "s,$MYTEMP,MYTEMP,"

if [ -z "$CPPFLAGS" ]
then
	found=no
	for head in \
		/usr/include \
		/usr/include/slang* \
		/usr/local/include \
		/usr/local/include/slang*
	do
		[ -d "$head" ] || continue
		[ -f "$head/slcurses.h" ] || continue
		if [ "$head" != /usr/include ]
		then
			CPPFLAGS="-I$head"
		fi
		found=yes
		break
	done
	[ $found = yes ] || failed "cannot find slcurses.h"
fi
CPPFLAGS="-I$MYTEMP"

if [ ! -t 1 ]
then
	verbose echo "CPPFLAGS $CPPFLAGS"
	verbose echo "LIBS     $LIBS"
	[ -n "$OPT_V" ] && ls -l $MYTEMP
fi

export CPPFLAGS
export LIBS

if [ $# != 0 ]
then
	"$@"
else
	[ -t 0 ] || failed "shell is not interactive"
	[ -t 1 ] || failed "shell is not interactive"
	${SHELL:=/bin/sh}
fi
